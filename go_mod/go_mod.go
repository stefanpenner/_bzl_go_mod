package go_mod

import (
	"bufio"
	"flag"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// goModLanguage implements Gazelle's language.Language interface and is responsible
// for generating a single go_mod rule for each Bazel package that contains a
// go.mod file. It only considers go_library targets, never go_binary.
type goModLanguage struct{}

// NewLanguage is the constructor that Gazelle looks for when loading this extension.
func NewLanguage() language.Language {
	return &goModLanguage{}
}

func (*goModLanguage) Name() string {
	return "go_mod"
}

func (*goModLanguage) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"go_mod": {
			NonEmptyAttrs: map[string]bool{
				"module_path": true,
				"go_mod":      true,
			},
			MergeableAttrs: map[string]bool{
				"deps": true,
			},
		},
	}
}

func (*goModLanguage) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "//:go_mod.bzl",
			Symbols: []string{"go_mod"},
		},
	}
}

func (*goModLanguage) Fix(*config.Config, *rule.File) {}

func (*goModLanguage) Configure(*config.Config, string, *rule.File) {}

func (*goModLanguage) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	res := language.GenerateResult{}

	// Only generate a rule if this package has a go.mod file in this directory.
	dir := args.Dir
	goModPath := filepath.Join(args.Dir, "go.mod")
	modulePath, err := parseModulePath(goModPath)
	if err != nil {
		// No go.mod or failed to parse it; do not generate anything.
		return res
	}

	// Collect go_library labels from this package:
	//   * existing rules in the current file, plus
	//   * rules generated by other languages (notably the Go language).
	labelsSet := map[string]bool{}

	for _, lbl := range collectGoLibraries(args.File) {
		labelsSet[lbl] = true
	}
	for _, r := range args.OtherGen {
		if r.Kind() == "go_library" {
			labelsSet[":"+r.Name()] = true
		}
	}

	var goLibs []string
	for lbl := range labelsSet {
		goLibs = append(goLibs, lbl)
	}
	sort.Strings(goLibs)

	// Reuse an existing go_mod rule name if present, otherwise use a stable default.
	name := "go_mod"
	if args.File != nil {
		for _, existing := range args.File.Rules {
			if existing.Kind() == "go_mod" {
				name = existing.Name()
				break
			}
		}
	}

	r := rule.NewRule("go_mod", name)
	r.SetAttr("module_path", modulePath)
	r.SetAttr("go_mod", ":go.mod")
	if fileExists(filepath.Join(dir, "go.sum")) {
		r.SetAttr("go_sum", ":go.sum")
	}
	r.SetAttr("deps", goLibs)

	res.Gen = append(res.Gen, r)
	res.Imports = make([]interface{}, len(res.Gen))
	return res
}

func (*goModLanguage) Imports(*config.Config, *rule.Rule, *rule.File) []resolve.ImportSpec {
	return nil
}

func (*goModLanguage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

func (*goModLanguage) Resolve(*config.Config, *resolve.RuleIndex, *repo.RemoteCache, *rule.Rule, interface{}, label.Label) {
}

func (*goModLanguage) RegisterFlags(*flag.FlagSet, string, *config.Config) {}

func (*goModLanguage) CheckFlags(*flag.FlagSet, *config.Config) error {
	return nil
}

func (*goModLanguage) KnownDirectives() []string {
	return nil
}

// parseModulePath reads the given go.mod file and returns the module path from
// the first 'module' directive it finds.
func parseModulePath(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			fields := strings.Fields(line)
			if len(fields) < 2 {
				return "", nil
			}
			mod := strings.Trim(fields[1], `"`)
			if mod == "" {
				return "", nil
			}
			return mod, nil
		}
	}
	if err := scanner.Err(); err != nil {
		return "", err
	}
	return "", os.ErrNotExist
}

func collectGoLibraries(f *rule.File) []string {
	if f == nil {
		return nil
	}
	var labels []string
	for _, r := range f.Rules {
		if r.Kind() == "go_library" {
			labels = append(labels, ":"+r.Name())
		}
	}
	return labels
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
