package go_mod

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// goModLanguage implements Gazelle's language.Language interface and is responsible
// for generating a single go_mod rule for each Bazel package that contains a
// go.mod file. It only considers go_library targets, never go_binary.
type goModLanguage struct{}

// NewLanguage is the constructor that Gazelle looks for when loading this extension.
func NewLanguage() language.Language {
	return &goModLanguage{}
}

func (*goModLanguage) Name() string {
	return "go_mod"
}

func (*goModLanguage) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"go_mod": {
			NonEmptyAttrs: map[string]bool{
				"module_path": true,
				"go_mod":      true,
			},
			MergeableAttrs: map[string]bool{
				"deps": true,
			},
		},
	}
}

func (*goModLanguage) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "//rules/go_mod:go_mod.bzl",
			Symbols: []string{"go_mod"},
		},
	}
}

func (*goModLanguage) Fix(*config.Config, *rule.File) {}

func (*goModLanguage) Configure(*config.Config, string, *rule.File) {}

func (*goModLanguage) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	res := language.GenerateResult{}

	// Only generate a rule if this package has a go.mod file in this directory.
	dir := args.Dir
	goModPath := filepath.Join(args.Dir, "go.mod")
	modulePath, err := parseModulePath(goModPath)
	if err != nil {
		// No go.mod or failed to parse it; do not generate anything.
		return res
	}

	// Collect go_library labels from this package:
	//   * existing rules in the current file, plus
	//   * rules generated by other languages (notably the Go language).
	labelsSet := map[string]bool{}

	for _, lbl := range collectGoLibraries(args.File, args.Rel) {
		labelsSet[lbl] = true
	}
	for _, r := range args.OtherGen {
		// Include all go_library rules from OtherGen unless they're slated for removal
		if r.Kind() == "go_library" {
			// Check ShouldKeep() to filter out rules explicitly marked for deletion.
			// Note: In real Gazelle execution, newly generated rules in OtherGen
			// should have ShouldKeep() return true unless explicitly deleted.
			if r.ShouldKeep() {
				// Use relative label format for same-package references
				labelsSet[":"+r.Name()] = true
			}
		}
	}

	var goLibs []string
	for lbl := range labelsSet {
		goLibs = append(goLibs, lbl)
	}
	sort.Strings(goLibs)

	// Reuse an existing go_mod rule name if present, otherwise use a stable default.
	name := "go_mod"
	if args.File != nil {
		for _, existing := range args.File.Rules {
			if existing.Kind() == "go_mod" {
				name = existing.Name()
				break
			}
		}
	}

	r := rule.NewRule("go_mod", name)
	r.SetAttr("module_path", modulePath)
	r.SetAttr("go_mod", ":go.mod")
	if fileExists(filepath.Join(dir, "go.sum")) {
		r.SetAttr("go_sum", ":go.sum")
	}
	r.SetAttr("deps", goLibs)

	res.Gen = append(res.Gen, r)
	res.Imports = make([]interface{}, len(res.Gen))
	return res
}

func (*goModLanguage) Imports(*config.Config, *rule.Rule, *rule.File) []resolve.ImportSpec {
	return nil
}

func (*goModLanguage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

func (*goModLanguage) Resolve(*config.Config, *resolve.RuleIndex, *repo.RemoteCache, *rule.Rule, interface{}, label.Label) {
}

func (*goModLanguage) RegisterFlags(*flag.FlagSet, string, *config.Config) {}

func (*goModLanguage) CheckFlags(*flag.FlagSet, *config.Config) error {
	return nil
}

func (*goModLanguage) KnownDirectives() []string {
	return nil
}

// parseModulePath reads the given go.mod file and returns the module path from
// the first 'module' directive it finds.
func parseModulePath(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// Check for module directive - must start with "module" followed by space or end of line
		if strings.HasPrefix(line, "module") {
			// Check if it's exactly "module" or "module " followed by content
			if len(line) == 6 || (len(line) > 6 && (line[6] == ' ' || line[6] == '\t')) {
				fields := strings.Fields(line)
				if len(fields) < 2 {
					return "", fmt.Errorf("invalid module directive in %s: missing module path", path)
				}
				// Handle quoted module paths. Go module paths can be quoted with double quotes.
				// Remove quotes only if they appear at the start and end of the field.
				mod := fields[1]
				if len(mod) >= 2 && mod[0] == '"' && mod[len(mod)-1] == '"' {
					mod = mod[1 : len(mod)-1]
				}
				if mod == "" {
					return "", fmt.Errorf("invalid module directive in %s: empty module path", path)
				}
				return mod, nil
			}
		}
	}
	if err := scanner.Err(); err != nil {
		return "", err
	}
	return "", errors.New("no module directive found")
}

func collectGoLibraries(f *rule.File, rel string) []string {
	if f == nil {
		return nil
	}
	var labels []string
	for _, r := range f.Rules {
		if r.Kind() == "go_library" && r.ShouldKeep() {
			// Use relative label format (":name") for same-package references.
			// This is the standard Bazel convention for targets in the same package.
			labels = append(labels, ":"+r.Name())
		}
	}
	return labels
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
